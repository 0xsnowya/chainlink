package vrf_test

import (
	"fmt"
	"math/big"
	"testing"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/smartcontractkit/chainlink/core/internal/cltest"
	"github.com/smartcontractkit/chainlink/core/services/vrf"
	"github.com/smartcontractkit/chainlink/core/store/models"
	"github.com/stretchr/testify/require"
)

func TestMultiwordVRFConsumer(t *testing.T) {
	key := cltest.MustGenerateRandomKey(t)
	coordinator := newVRFCoordinatorUniverse(t, key)
	contract := coordinator.multiwordConsumerContract
	keyHash, _, fee := registerProvingKey(t, coordinator)
	numwords := 50
	bigNumwords := big.NewInt(int64(numwords))
	seed := 0
	_, err := contract.TestRequestRandomness(
		coordinator.carol, keyHash, fee, big.NewInt(int64(seed)), bigNumwords)
	require.NoError(t, err, "could not send randomness request")
	coordinator.backend.Commit()

	rawLog, err := coordinator.rootContract.FilterRandomnessRequest(nil, nil)
	require.NoError(t, err, "failed to subscribe to RandomnessRequest logs")
	logCount := 0
	for rawLog.Next() {
		logCount += 1
	}
	require.Equal(t, 1, logCount, "unexpected log generated by randomness request to VRFCoordinator")
	log := models.RawRandomnessRequestLogToRandomnessRequestLog(
		(*models.RawRandomnessRequestLog)(rawLog.Event))

	preSeed, err := vrf.BigToSeed(log.Seed)
	require.NoError(t, err, "pre-seed %x out of range", preSeed)
	s := vrf.PreSeedData{
		PreSeed:   preSeed,
		BlockHash: log.Raw.Raw.BlockHash,
		BlockNum:  log.Raw.Raw.BlockNumber,
	}
	proofBlob, err := vrf.GenerateProofResponseWithNonce(rawSecretKey, s, big.NewInt(1) /* nonce */)
	require.NoError(t, err, "could not generate VRF proof!")
	// Seems to be a bug in the simulated backend: without this extra Commit, the
	// EVM seems to think it's still on the block in which the request was made,
	// which means that the relevant blockhash is unavailable.
	coordinator.backend.Commit()

	// Seems to be a bug in the simulated backend: without this extra Commit, the
	// EVM seems to think it's still on the block in which the request was made,
	// which means that the relevant blockhash is unavailable.
	coordinator.backend.Commit()
	// Set a high gas limit, since otherwise the fulfillRandomnessRequest will
	// fail silently.
	var neil bind.TransactOpts = *coordinator.neil
	neil.GasLimit = 8_000_000
	_, err = coordinator.rootContract.FulfillRandomnessRequest(&neil, proofBlob[:])
	require.NoError(t, err, "failed to fulfill randomness request!")
	coordinator.backend.Commit()

	for i := 0; i < numwords; i++ {
		randomness, err := contract.RandomnessOutput(nil, big.NewInt(int64(i)))
		fmt.Println("i", i)
		require.NoError(t, err, "could not check randomness output")
		require.NotEqual(t, [32]byte{}, randomness, "randomness not set")
	}
}
